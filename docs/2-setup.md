# Setup and Configuration

Setting up IoTSuite is fairly straightforward. Everything is defined in the configuration file, and IoTSuite itself is fairly flexible in allowing for different set-up configurations.

## System Requirements

IoTSuite only runs on Linux. It is recommended to have at least kernel version 5.10.

The following external programs are required for IoTSuite to work:

- A Python 3 interpreter
- QEMU, a system emulator
- `iproute`, providing the `ip` command
- `sudo`
- `buildroot`, if building the VM images

## Obtaining the VM images

The sandbox VMs are compiled using Buildroot, a build system built on GNU Make that takes an auto-generated configuration file and compiles a completely custom embedded Linux system for each architecture. The config files for each architecture can be found in the `configs` directory.

The CNC VM is a standard Ubuntu Server distribution, installed to a disk image file supported by QEMU. Currently IoTSuite only supports the QCOW2 format.

### Self-Compiling the Sandboxes

To self-compile the sandbox VMs, you will need to have a working knowledge of the Buildroot project. The documentation can be found [here](https://buildroot.org/downloads/manual/manual.html). The general idea is that Buildroot leverages the `make` build system to create an auto-compiling setup that can produce a custom embedded Linux distro for most embedded architectures.

It is highly recommended to use the `buildroot` submodule in this project's root directory. This contains extra Perl modules that while not used, may come in handy in the future.

To obtain a fresh slate of Buildroot, you need to run a defconfig command. This sets up basic configuration of the machine and architecture you are compiling for, and sets all the default compilation options for that machine. A list of all machines can be found by running `ls` on the `configs` directory in the `buildroot` submodule, and can be run like so:

```text
make <whatever_defconfig>
```

So, for example, for ARM on QEMU, you would run:

```shell
make qemu_arm_versatile_defconfig
```

Buildroot uses a master configuration file, `.config`, to define the build. This is the file first generated by the defconfig command, and is customized by running `make nconfig` in the buildroot submodule, which brings up an ncurses TUI interface, and allows you to tweak compilation options however you like. A complete list of packages can be found [here](packagelist.md).

However to save you the time, configuration files for each architecture have already been created in advance and can be found in the `configs` directory with the names `<arch>-config`. Just copy the file to the `buildroot` submodule and rename the file to `.config` and Buildroot will be configured to compile the sandbox VM for the selected architecture.

For example, for the ARM configuration file:

```shell
# in the project root
cp configs/arm-config buildroot/.config
```

However, before we start compiling, we need to understand how we get our custom files onto the sandbox filesystem. In order to get the analysis script onto the sandbox VM, IoTSuite makes use of Buildroot's root filesystem overlay system. Essentially, an external module is created by [defining a `BR2_EXTERNAL` make variable](https://buildroot.org/downloads/manual/manual.html#outside-br-custom) to serve as an out-of-tree directory. This directory contains custom files as well as the root filesystem overlay. The external directory for this project is the `br-external` directory found in the project root, and the directory overlaid on the root filesystem is `br-external/rootfs`.

In order to set this makefile variable, just run `make` with the following additional argument, once you have copied and renamed the config file:

```shell
make BR2_EXTERNAL=/path/to/project/br-external
```

This will start the compilation process with the external directory set correctly. It is highly recommended that you use an absolute path, and avoid relative paths whenever possible.

Once compilation is complete, the finished images can be found in `output/images` in the `buildroot` submodule. There are usually 3 files present - a `rootfs.ext2` file, a `vmlinux` file, and a `start-qemu.sh` shell script. These are the root filesystem image, the kernel image, and a convenience script for starting QEMU respectively. In the case of ARM, an additional Device Tree Blob file called `versatilepb.dtb` is also produced.

To reset Buildroot after compiling, run:

```shell
make clean
```

This will clear all compiled files, but keep the configuration file.

### Additional Processing

Additional processing is needed after the compilation is complete. The files need to be renamed and the root filesystem image needs to be converted into a format usable by IoTSuite. The QCOW2 format is a disk image format developed for QEMU that allows snapshots to be created, as opposed to a raw filesystem image. This is needed to reset the VM every time a sample is finished processing.

The kernel file `vmlinux` should be renamed to `kernel.img`, and the root filesystem image should be comverted to a QCOW2 image using the following commands:

```shell
qemu-img convert -O qcow2 rootfs.ext2 rootfs.qcow2
qemu-img snapshot -c clean rootfs.qcow2
```

This uses the `qemu-img` tool to convert the filesystem image format and save a clean snapshot.

### Setting up the Fake C2

Unlike the sandbox, you cannot compile the sandbox VM from source. It uses an x86_64 Ubuntu Server distribution.

TODO

## Directory Structure

Each architecture has its own directory where the VM image is stored. This can be any directory in any part of the filesystem, as long as the user has access rights. However, due to the way Buildroot compiles the images for a QEMU target, each directory needs the following required files for each embedded architecture (i.e. ARM, MIPS, etc.):

- `kernel.img`. This is the compiled kernel image.
- `rootfs.qcow2`. This is the root filesystem image. All the required scripts and tools are already installed within the filesystem due to Buildroot's filesystem overlay functionality. This file should not be a raw filesystem, but a QCOW2 image as mentioned earlier.

ARM requires an additional file: `versatile-pb.dtb`. This is the Device Tree Blob (DTB) file required by QEMU when starting the system.

These filenames *must* be named as given; these names are hardcoded into IoTSuite. (See `arch.py` in the source code for details.)

Similarly, the CNC VM image uses its own directory, and is treated as its own architecture by IoTSuite. The following files are required:

- `rootfs.qcow2`. This is the root filesystem, with the kernel installed within it.

## CNC VM Setup

While the sandbox VMs may be already set up, setting up the CNC VM requires some additional work. A shell script is provided to start up the CNC VM with internet access, allowing the user to update the system and install the required tools.

TODO - installing cowrie, setting up SSH, disabling resolved, enabling fakedns

## Installing the Source Code

IoTSuite is a Python program, and thus can run on any Linux machine with a Python 3 interpreter.

IoTSuite requires the following Python libraries:

- `python-magic` - a Python wrapper for libmagic
- `pyelftools` - native Python library for parsing ELF files
- `pexpect` - library for interacting with programs through stdin
- `fabric` - library for SSH communication on Python
- `invoke` - library for invoking shell commands
- `ppdeep` - a Python library for context-triggered piecewise hashing (CTPH)
